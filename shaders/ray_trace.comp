#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform image2D colorBuffer;

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
};

struct Camera {
    vec3 position;
    vec3 forwards;
    vec3 right;
    vec3 up;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

float hit(Ray ray, Sphere sphere);
vec3 ray_at(Ray ray, float t);

void main() {
    ivec2 screen_pos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    ivec2 screen_size = imageSize(colorBuffer);
    vec2 coefficient = vec2(
        (2.0 * float(screen_pos.x) - screen_size.x) / screen_size.x,
        (2.0 * float(screen_pos.y) - screen_size.y) / screen_size.x
    );
    vec4 pixel_color = vec4(0.0);
    Camera camera;
    Sphere sphere;
    Ray ray;

    camera.position = vec3(0.0);
    camera.forwards = vec3(1.0, 0.0, 0.0);
    camera.right = vec3(0.0, -1.0, 0.0);
    camera.up = vec3(0.0, 0.0, 1.0);

    sphere.center = vec3(4.0, 0.0, 0.0);
    sphere.radius = 1.0;
    sphere.color = vec3(1.0, 0.0, 0.0);

    ray.origin = camera.position;
    ray.direction = camera.forwards + coefficient.x * camera.right + coefficient.y * camera.up;
    float t = hit(ray, sphere);

    if (t > 0.0) {
        vec3 N = normalize(ray_at(ray, t) - sphere.center);
        pixel_color = vec4(0.5 * (N + vec3(1.0)), 1.0);
    }

    imageStore(colorBuffer, screen_pos, pixel_color);
}

float hit(Ray ray, Sphere sphere) {
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(ray.direction, oc);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = half_b * half_b - a * c;

    if (discriminant < 0.0) {
        return -1.0;
    } else {
        return -(half_b + sqrt(discriminant)) / a;
    }
}

vec3 ray_at(Ray ray, float t) {
    return ray.origin + t * ray.direction;
}
